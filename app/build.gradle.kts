import java.io.BufferedOutputStream
import java.io.File
import java.io.FileOutputStream
import java.util.zip.ZipEntry
import java.util.zip.ZipFile
import java.util.zip.ZipOutputStream
import kotlin.system.exitProcess

/*
 * This file was generated by the Gradle 'init' task.
 *
 * This generated file contains a sample Kotlin application project to get you started.
 * For more details on building Java & JVM projects, please refer to https://docs.gradle.org/8.5/userguide/building_java_projects.html in the Gradle documentation.
 */

plugins {
    // Apply the org.jetbrains.kotlin.jvm Plugin to add support for Kotlin.
    alias(libs.plugins.jvm)

    // Apply the application plugin to add support for building a CLI application in Java.
    application
}

repositories {
    // Use Maven Central for resolving dependencies.
    mavenCentral()
}

dependencies {

    // This dependency is used by the application.
    implementation(libs.guava)
}

// Apply a specific Java toolchain to ease working on different environments.
java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(21))
    }
}

tasks.named("compileKotlin", org.jetbrains.kotlin.gradle.tasks.KotlinCompilationTask::class.java) {
    compilerOptions {
        freeCompilerArgs.add("-include-runtime")
    }
}

application {
    // Define the main class for the application.
    mainClass.set("MainKt")
}

tasks.withType<Jar> {

    manifest {
        attributes["Main-Class"] = "MainKt"
    }



    // adds kotlin runtime file to jar if kotlin compiler found on environment path
    doLast {
        val jarName = project.buildFile.parent.toString().let {
            it.substring(it.lastIndexOf("/") + 1)
        } + ".jar"
        val buildPath = project.buildFile.parent + "/build"

        println( "Create Cache Directory for Runtime" )
        val runtimeCache = "$buildPath/tmp/RuntimeCache"
            .also { it ->
                File( it ).let {
                    if ( !it.isDirectory ) it.mkdirs()
                }
            }

        println( "Writing Dummy File To Compile With Runtime" )
        File("$runtimeCache/dummy.kt")
            .let {
                if ( ! it.isFile ) it.writeText(
                    "fun main() = println(\"Dummy File\") "
                )
            }

        if ( ! File("$runtimeCache/dummy.jar").isFile ) {
            println( "Compiling Dummy File With Runtime" )
            val command =
                "kotlinc $runtimeCache/dummy.kt -include-runtime -d $runtimeCache/dummy.jar"

            try {
                ProcessBuilder()
                    .command(command.split(" "))
                    .directory(rootProject.projectDir)
                    .redirectOutput(ProcessBuilder.Redirect.INHERIT)
                    .redirectError(ProcessBuilder.Redirect.INHERIT)
                    .start()
                    .waitFor(60, TimeUnit.SECONDS)
            } catch (_: Exception) {
                File( runtimeCache ).deleteRecursively()
                println("Failed To Add Runtime File To Jar, Compiler Not Accessible\n")
                return@doLast
            }
        }

        val unzip : ( String , String ) -> Unit = { zipFileName , outputDirectory ->
            File( outputDirectory ).let { extractedFile ->
                if (extractedFile.isDirectory) return@let
                else extractedFile.mkdirs()
                ZipFile( zipFileName ).let { zip ->
                    zip.entries().asSequence().forEach { file ->
                        if (file.isDirectory) {
                            File("$extractedFile/$file").let {
                                if (!it.isDirectory) it.mkdirs()
                            }
                        } else {
                            file.toString().let {
                                if (it.contains("/")) {
                                    File(extractedFile.toString() + "/" + it.substring(0, it.lastIndexOf("/"))).mkdirs()
                                }
                            }
                            zip.getInputStream(file).let { zipFile ->
                                File("$extractedFile/$file").let {
                                    if (!it.isFile) it.writeBytes(zipFile.readAllBytes())
                                }
                            }

                        }
                    }
                }
            }
        }

        val zip : ( String , String ) -> Unit = { inputFiles , targetZip ->
            ZipOutputStream( BufferedOutputStream( FileOutputStream( targetZip ) ) ).use { zip ->
                File( inputFiles ).walk().forEach { file ->
                    if ( file.isFile ) {
                        file.inputStream().use { inputStream ->
                            val entry = ZipEntry(file.toString().replace( inputFiles , "" ).substring( 1 ) )
                            zip.putNextEntry(entry)
                            inputStream.copyTo(zip, 1024)
                        }
                    }
                }
            }
        }

        // extract Runtime File
        println( "Extracting Runtime File" )
        unzip( "$runtimeCache/dummy.jar" , "$runtimeCache/runtime" )

        println( "Extracting Program File" )
        unzip( "$buildPath/libs/$jarName" , "$buildPath/libs/${jarName}Dir" )

        println( "Copying Runtime File" )
        File( "$runtimeCache/runtime/kotlin" ).copyRecursively(
            File( "$buildPath/libs/${jarName}Dir/kotlin" ) , true
        )
        println( "Delete Old Jar File" )
        File( "$buildPath/libs/$jarName" ).delete()

        println( "Zipping Program File With Runtime File" )
        zip( "$buildPath/libs/${jarName}Dir" , "$buildPath/libs/$jarName" )

        println( "Clean Up" )
        File( "$buildPath/libs/${jarName}Dir" ).deleteRecursively()

        println( "Success : Added Runtime Files to Jar" )

    }

}
